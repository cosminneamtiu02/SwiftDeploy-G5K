name: Shell quality

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review, labeled, unlabeled]
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      debug:
        description: "Enable debug mode (prints more logs, runs self-test)"
        type: boolean
        default: false

permissions:
  contents: read
  pull-requests: write
  checks: write
  security-events: write

env:
  SHELL_PATHS_FILE: ".shell_paths"

jobs:
  # ================= 0) Sanity/self-test (only when debug is on) =================
  sanity_debug:
    name: Sanity & self-test
    runs-on: ubuntu-latest
    if: ${{ (github.event_name == 'workflow_dispatch' && inputs.debug)
          || (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'ci-debug')) }}

    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y shellcheck
          SHFMT_VERSION=3.9.0
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64) ARCH=amd64 ;;
            aarch64) ARCH=arm64 ;;
          esac
          curl -sSL -o /usr/local/bin/shfmt \
            "https://github.com/mvdan/sh/releases/download/v${SHFMT_VERSION}/shfmt_v${SHFMT_VERSION}_${OS}_${ARCH}"
          sudo chmod +x /usr/local/bin/shfmt
          shellcheck --version
          shfmt -version

      - name: Create throwaway scripts (good/bad)
        run: |
          set -euxo pipefail
          mkdir -p .ci-selftest
          cat > .ci-selftest/good.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          msg="hello"
          echo "$msg"
          EOF
          chmod +x .ci-selftest/good.sh
          cat > .ci-selftest/bad.sh <<'EOF'
          #!/usr/bin/env bash
          set -euo pipefail
          msg=hello
          echo $msg
          if [ "$msg" = "hello" ]; then
          echo ok
          fi
          EOF
          chmod +x .ci-selftest/bad.sh

      - name: shellcheck should report findings
        run: |
          set +e
          shellcheck -x -S style -f gcc .ci-selftest/good.sh .ci-selftest/bad.sh
          ec=$?
          echo "shellcheck exit: $ec (expect non-zero)"; test $ec -ne 0

      - name: shfmt should show diff for bad.sh
        run: |
          set -e
          if shfmt -i 2 -ci -d .ci-selftest/*.sh; then
            echo "Unexpected: shfmt returned 0 (no diff)"; exit 1
          else
            echo "Expected: shfmt returned non-zero due to formatting diff"
          fi

      - name: bash -n should parse both
        run: |
          set -e
          bash -n .ci-selftest/good.sh
          bash -n .ci-selftest/bad.sh
          echo "Syntax OK"

  # ================= 1) Advisory reviewer (PR comments + SARIF; non-blocking) =================
  reviewer_advice:
    name: Shell review (advisory)
    runs-on: ubuntu-latest

    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y shellcheck
          SHFMT_VERSION=3.9.0
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64) ARCH=amd64 ;;
            aarch64) ARCH=arm64 ;;
          esac
          curl -sSL -o /usr/local/bin/shfmt \
            "https://github.com/mvdan/sh/releases/download/v${SHFMT_VERSION}/shfmt_v${SHFMT_VERSION}_${OS}_${ARCH}"
          sudo chmod +x /usr/local/bin/shfmt
          echo "== Versions =="; shellcheck --version; shfmt -version

      - name: Setup reviewdog (pinned)
        uses: reviewdog/action-setup@e04ffabe3898a0af8d0fb1af00c188831c4b5893 # v1.3.2
        with:
          reviewdog_version: latest

      - name: Build file list (extensions + shebang scan)
        id: files
        shell: bash
        run: |
          set -euo pipefail
          tmp="$(mktemp)"
          detect_shell() {
            while IFS= read -r -d '' f; do
              if head -c 1024 "$f" | grep -aqE '^#!.*\b(bash|sh|zsh)\b'; then
                printf '%s\0' "$f"
              fi
            done
          }
          if [[ -f "$SHELL_PATHS_FILE" ]]; then
            mapfile -t dirs < <(sed -E 's/#.*$//; s/^[[:space:]]+|[[:space:]]+$//g; /^$/d' "$SHELL_PATHS_FILE")
            if ((${#dirs[@]})); then
              while IFS= read -r -d '' f; do printf '%s\0' "$f"; done < <(
                printf '%s\0' "${dirs[@]}" |
                xargs -0 -I{} find "{}" -type f -regextype posix-extended \
                  -regex '.*\.(sh|bash|zsh)$' -print0 2>/dev/null
              ) > "$tmp"
              printf '%s\0' "${dirs[@]}" |
              xargs -0 -I{} find "{}" -type f -perm -111 -print0 2>/dev/null |
              detect_shell >> "$tmp"
            else : > "$tmp"; fi
          else
            git ls-files -z -- '*.sh' '*.bash' '*.zsh' > "$tmp"
            git ls-files -z | xargs -0 -I{} -- file -b "{}" | paste -d '\0' - - |
            awk -v RS='\0' 'NR%2==1{f=$0} NR%2==0{ if($0 ~ /shell script/) print f "\0" }' >> "$tmp"
          fi
          tr '\0' '\n' < "$tmp" | sort -u | tee files.debug | tr '\n' '\0' > files.list
          echo "count=$(tr -cd '\0' < files.list | wc -c)" >> "$GITHUB_OUTPUT"
          echo "== Files considered =="; cat files.debug

      - name: (Debug) Show first lines of each file
        if: ${{ steps.files.outputs.count != '0' && (
                (github.event_name == 'workflow_dispatch' && inputs.debug) ||
                (github.event_name == 'pull_request' && contains(github.event.pull_request.labels.*.name, 'ci-debug'))
              ) }}
        run: |
          while IFS= read -r f; do
            echo "----- $f -----"
            sed -n '1,200p' "$f"
          done < files.debug

      - name: shellcheck with reviewdog (PR comments; non-blocking)
        if: ${{ steps.files.outputs.count != '0' && github.event_name == 'pull_request' }}
        env:
          REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set +e
          xargs -0 shellcheck -f checkstyle --external-sources --severity=style < files.list \
            > shellcheck_checkstyle.xml || true
          reviewdog -f=checkstyle -name="shellcheck" \
            -reporter=github-pr-review -level=warning -filter-mode=diff \
            -fail-on-error=false -tee < shellcheck_checkstyle.xml

      - name: Generate shfmt diff
        if: ${{ steps.files.outputs.count != '0' && github.event_name == 'pull_request' }}
        id: shfmt
        run: |
          set -e
          xargs -0 shfmt -i 2 -ci -s -fn -d < files.list > shfmt.diff || true
          if [[ -s shfmt.diff ]]; then echo "has_diff=true" >> "$GITHUB_OUTPUT"; else echo "has_diff=false" >> "$GITHUB_OUTPUT"; fi

      - name: shfmt suggestions via reviewdog (PR comments; non-blocking)
        if: ${{ steps.shfmt.outputs.has_diff == 'true' }}
        env:
          REVIEWDOG_GITHUB_API_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          reviewdog -f=diff -name="shfmt" \
            -reporter=github-pr-review -filter-mode=diff \
            -fail-on-error=false -tee < shfmt.diff

      - name: shellcheck → SARIF (non-blocking)
        if: ${{ steps.files.outputs.count != '0' }}
        run: |
          xargs -0 shellcheck -f sarif -S style < files.list > shellcheck.sarif || true

      - name: Upload SARIF
        if: ${{ steps.files.outputs.count != '0' }}
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: shellcheck.sarif

  # ================= 2) Blocking gatekeeper (use in Branch protection) =================
  gatekeeper:
    name: Shell gatekeeper (blocking)
    runs-on: ubuntu-latest
    if: ${{ github.event_name == 'pull_request' && github.event.pull_request.draft == false }}

    steps:
      - uses: actions/checkout@v4

      - name: Install tools
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y shellcheck
          SHFMT_VERSION=3.9.0
          OS=$(uname -s | tr '[:upper:]' '[:lower:]')
          ARCH=$(uname -m)
          case "$ARCH" in
            x86_64) ARCH=amd64 ;;
            aarch64) ARCH=arm64 ;;
          esac
          curl -sSL -o /usr/local/bin/shfmt \
            "https://github.com/mvdan/sh/releases/download/v${SHFMT_VERSION}/shfmt_v${SHFMT_VERSION}_${OS}_${ARCH}"
          sudo chmod +x /usr/local/bin/shfmt
          echo "== Versions =="; shellcheck --version; shfmt -version

      - name: Find shell scripts (fast path by extensions)
        id: files
        run: |
          set -euo pipefail
          mapfile -t scripts < <(git ls-files \
            '*.sh' '*.bash' '*.zsh' ':!:**/node_modules/**' ':!:**/vendor/**')
          printf '%s\n' "${scripts[@]}" | tee scripts.txt
          echo "count=${#scripts[@]}" >> "$GITHUB_OUTPUT"

      - name: Skip if none
        if: ${{ steps.files.outputs.count == '0' }}
        run: echo "No shell files in repo — skipping gatekeeper." && exit 0

      - name: Syntax check (bash -n / zsh -n)
        run: |
          set -euo pipefail
          echo "== Syntax check =="
          while read -r f; do
            case "$f" in
              *.zsh)  echo "zsh -n $f";  zsh -n "$f" ;;
              *)      echo "bash -n $f"; bash -n "$f" ;;
            esac
          done < scripts.txt

      - name: shellcheck (fail on findings)
        run: |
          set -euo pipefail
          echo "== shellcheck findings (if any) =="
          xargs -a scripts.txt shellcheck -x -S style -f gcc

      - name: shfmt (enforce formatting; fail on diff)
        run: |
          set -euo pipefail
          echo "== shfmt diff (should be empty) =="
          shfmt -i 2 -ci -d $(cat scripts.txt)
